1. TABLE TESTING OVERLY COMPLEX AND NOT ALWAYS PRACTICAL
- table testing can have problems because the following is weird and thinks first and second do not have to have the same type:

type TR<E> = [ string, E, E, E ];
describe('+', () => {
    const table: (TR<number> | TR<string>)[] = [
        [ 'numeric addition succeeds', 1, 2, 3 ],
        [ 'string concatenation succeeds', 'foo', 'bar', 'foobar '],
    ];

    test.each(table)('%s', (_, first, second, result) => {
        expect(first + second).toStrictEqual(result);
    });
});

Solution is something like this:
type TTR<T> = [ string, T[] ];

function x<T>(a: T, b: T) { return (a as number) + (b as number); }

const table: (TTR<number> | TTR<string>)[] = [
    [ 'numeric addition succeeds', [ 1, 2, 3 ] ],
    [ 'string concatenation succeeds', [ 'foo', 'bar', 'foobar' ] ],
];

table.forEach(([ _, [ a, b, c ] ]) => {
    console.log(`${_}: is equal? ${x(a, b) === c}`);
});

2. REPLACER IS A MESS
- replacer is still problematic, even with sequences/generic.ts containing this:
- perhaps two types of replacer? replaceWithSingleValue() v replaceWithMultipleValues?
protected override replacer<FromT>(r: Replacer<FromT, ET>, curr: FromT, i: number): ET[] {
    const retval = typeof r === 'function' ? r(curr, i) : r;

    if (retval instanceof Sequence) {
        return retval.contents;
    }

    if (Array.isArray(retval)) {
        return retval.map(v => this.constructMember(v));
    }

    return [ this.constructMember(retval as SeqMemberArgument) ];
}

concerns:
- different typing from in collection makes this messy AF to implement
- [ a, b, c ] could mean a chord containing [ a, b, c ] or a melody containing [ [ a ], [ b ], [ c ] ]